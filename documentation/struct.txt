ğŸ—ï¸ Estrutura do Projeto web-scraper-tool Detalhada

web-scraper-tool/
â”œâ”€â”€ ğŸ“š documentation/
â”‚   â””â”€â”€ ğŸ“„ DOCUMENTATION.md
â”‚   â””â”€â”€ ğŸ“„ structure.txt
â”‚
â”œâ”€â”€ ğŸ“¦ node_modules/
â”‚   â””â”€â”€ (MÃ³dulos instalados pelo npm)
â”‚
â”œâ”€â”€ ğŸ“Š database/
â”‚   â”œâ”€â”€ ğŸ“± devices.json
â”‚   â””â”€â”€ ğŸŒ proxies.json
â”‚
â”œâ”€â”€ ğŸ’¡ examples/
â”‚   â”œâ”€â”€ ğŸ”° basic/
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ single-request.ts
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ single-request-with-proxy.ts
â”‚   â”‚   â””â”€â”€ ğŸ“„ single-request-with-random-proxies.ts
â”‚   â””â”€â”€ ğŸš€ advanced/
â”‚       â”œâ”€â”€ ğŸ“„ multiple-requests.ts
â”‚       â”œâ”€â”€ ğŸ“„ multiple-requests-with-proxy.ts
â”‚       â”œâ”€â”€ ğŸ“„ multiple-requests-with-random-proxies.ts
â”‚       â””â”€â”€ ğŸ“„ parallel-requests.ts
â”‚
â”œâ”€â”€ ğŸ’» src/
â”‚   â”œâ”€â”€ âš™ï¸ config.ts
â”‚   â”œâ”€â”€ ğŸ“„ index.ts
â”‚   â”œâ”€â”€ ğŸ“œ interfaces/
â”‚   â”‚   â”œâ”€â”€ âš™ï¸ IConfig.ts
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ IProxy.ts
â”‚   â”‚   â””â”€â”€ ğŸ“ IScraperOptions.ts
â”‚   â”œâ”€â”€ ğŸ› ï¸ services/
â”‚   â”‚   â”œâ”€â”€ ğŸ“¡ Proxy.ts
â”‚   â”‚   â””â”€â”€ ğŸ”— Request.ts
â”‚   â”œâ”€â”€ ğŸ“ types/
â”‚   â”‚   â””â”€â”€ ğŸ·ï¸ index.d.ts
â”‚   â””â”€â”€ ğŸ§° utils/
â”‚       â”œâ”€â”€ âœï¸ DataFormatter.ts
â”‚       â”œâ”€â”€ ğŸ”’ Security.ts
â”‚       â”œâ”€â”€ â³ Delay.ts
â”‚       â””â”€â”€ ğŸ“¢ Logger.ts
â”‚
â”œâ”€â”€ ğŸ“„ package.json
â”œâ”€â”€ ğŸ”’ package-lock.json
â”œâ”€â”€ ğŸ“– README.md
â””â”€â”€ ğŸ“ tsconfig.json

ExplicaÃ§Ã£o Detalhada de Pastas e Arquivos:
web-scraper-tool/ (Raiz do Projeto)
Esta Ã© a pasta principal da ferramenta de web scraping. Ela contÃ©m todos os arquivos e diretÃ³rios essenciais para o desenvolvimento, execuÃ§Ã£o e documentaÃ§Ã£o do projeto. Ã‰ o ponto de entrada para o sistema.

ğŸ“š documentation/ (Pasta)
PropÃ³sito: ContÃ©m toda a documentaÃ§Ã£o do projeto, servindo como um guia completo para usuÃ¡rios e desenvolvedores.

Por que usar: Essencial para a manutenibilidade e usabilidade da ferramenta. Garante que qualquer pessoa possa entender como configurar, usar e contribuir para o projeto sem precisar analisar o cÃ³digo fonte extensivamente.

Como usar: Adicione aqui guias de inÃ­cio rÃ¡pido, exemplos de uso avanÃ§ado e uma referÃªncia completa da API.

ğŸš€ GETTING_STARTED.md:

PropÃ³sito: Guia passo a passo para configurar e executar a ferramenta pela primeira vez.

Uso: Deve incluir instruÃ§Ãµes sobre instalaÃ§Ã£o de dependÃªncias, configuraÃ§Ã£o inicial e um exemplo bÃ¡sico de como iniciar um scrape.

ğŸ“– ADVANCED_USAGE.md:

PropÃ³sito: Demonstra exemplos mais complexos da ferramenta, como raspagem em lote, uso de proxies avanÃ§ados e configuraÃ§Ãµes personalizadas.

Uso: Ajuda os usuÃ¡rios a explorar todo o potencial da ferramenta alÃ©m do bÃ¡sico.

ğŸ“˜ API_REFERENCE.md:

PropÃ³sito: DocumentaÃ§Ã£o detalhada de todas as classes, mÃ©todos, interfaces e tipos pÃºblicos da ferramenta.

Uso: Serve como um manual para desenvolvedores que desejam integrar ou estender a ferramenta.

ğŸ“¦ node_modules/ (Pasta)
PropÃ³sito: Armazena todas as dependÃªncias (bibliotecas de terceiros) que seu projeto utiliza, instaladas via npm ou Yarn.

Por que usar: O Node.js e o TypeScript dependem de mÃ³dulos externos para a maioria das funcionalidades. Esta pasta Ã© gerenciada automaticamente pelo gerenciador de pacotes (npm install).

Como usar: VocÃª nÃ£o interage diretamente com esta pasta. As dependÃªncias sÃ£o declaradas no package.json e instaladas automaticamente.

ğŸ“Š database/ (Pasta)
PropÃ³sito: Guarda arquivos JSON com dados de configuraÃ§Ã£o e recursos que a ferramenta utiliza, como listas de agentes de usuÃ¡rio (user-agents) ou proxies.

Por que usar: Centraliza dados importantes que podem ser facilmente atualizados ou configurados sem alterar o cÃ³digo-fonte principal.

Como usar: Os serviÃ§os da aplicaÃ§Ã£o leem e utilizam esses arquivos para configurar o comportamento do scraper.

ğŸ“± devices.json:

PropÃ³sito: Lista de User-Agents e viewports para simular diferentes tipos de dispositivos (desktop, mobile, tablet) durante as requisiÃ§Ãµes.

Uso: Usado pela ferramenta para randomizar ou especificar o agente de usuÃ¡rio, imitando o acesso de navegadores reais e evitando detecÃ§Ã£o.

ğŸŒ proxies.json:

PropÃ³sito: Armazenar uma lista de servidores proxy que podem ser usados para rotear as requisiÃ§Ãµes de scraping.

Uso: O Proxy pode ler este arquivo para carregar proxies estÃ¡ticos, alÃ©m de buscar de APIs externas. Crucial para evitar bloqueios por IP.

ğŸ’¡ examples/ (Pasta)
PropÃ³sito: ContÃ©m exemplos de cÃ³digo que demonstram como usar a ferramenta em diferentes cenÃ¡rios, desde o bÃ¡sico atÃ© o mais avanÃ§ado.

Por que usar: Facilita o aprendizado e a compreensÃ£o da API da ferramenta, permitindo que os usuÃ¡rios vejam o cÃ³digo em aÃ§Ã£o.

Como usar: Os exemplos sÃ£o arquivos TypeScript que podem ser compilados e executados para ilustrar funcionalidades especÃ­ficas.

ğŸ”° basic/ (Subpasta):

PropÃ³sito: Exemplos de uso fundamental da ferramenta.

Uso: Mostra como realizar as tarefas mais simples, servindo como ponto de partida.

ğŸ“„ single-request.ts: Exemplo de uma Ãºnica requisiÃ§Ã£o HTTP sem proxies.

ğŸ“„ single-request-with-proxy.ts: Exemplo de uma Ãºnica requisiÃ§Ã£o usando um proxy especÃ­fico.

ğŸ“„ single-request-with-random-proxies.ts: Exemplo de uma Ãºnica requisiÃ§Ã£o utilizando proxies aleatÃ³rios da lista disponÃ­vel.

ğŸš€ advanced/ (Subpasta):

PropÃ³sito: Exemplos que demonstram funcionalidades mais complexas e poderosas.

Uso: Inspira e guia os usuÃ¡rios para cenÃ¡rios de uso mais sofisticados.

ğŸ“„ multiple-requests.ts: Exemplo de como realizar vÃ¡rias requisiÃ§Ãµes consecutivas.

ğŸ“„ multiple-requests-with-proxy.ts: Exemplo de mÃºltiplas requisiÃ§Ãµes usando um proxy especÃ­fico.

ğŸ“„ multiple-requests-with-random-proxies.ts: Exemplo de mÃºltiplas requisiÃ§Ãµes com rotaÃ§Ã£o de proxies aleatÃ³rios.

ğŸ“„ parallel-requests.ts: Exemplo de como fazer requisiÃ§Ãµes simultÃ¢neas para otimizar o tempo de execuÃ§Ã£o.

ğŸ’» src/ (Pasta)
PropÃ³sito: ContÃ©m o cÃ³digo-fonte principal da sua ferramenta, escrito em TypeScript.

Por que usar: Ã‰ onde a lÃ³gica de negÃ³cio e as funcionalidades do scraper sÃ£o implementadas e organizadas. A separaÃ§Ã£o do restante dos arquivos (configuraÃ§Ãµes, exemplos) mantÃ©m o projeto limpo.

Como usar: Todos os mÃ³dulos sÃ£o importados e exportados entre si para construir a funcionalidade completa da ferramenta.

âš™ï¸ config.ts:

PropÃ³sito: Define as configuraÃ§Ãµes globais da ferramenta, como diretÃ³rio de saÃ­da, timeouts, limites de retentativa e comportamento de proxies.

Uso: As configuraÃ§Ãµes sÃ£o importadas e usadas por diferentes serviÃ§os e utilitÃ¡rios para padronizar o comportamento. Pode ser sobrescrito por opÃ§Ãµes especÃ­ficas de scrape.

ğŸ¯ index.ts:

PropÃ³sito: O ponto de entrada principal da sua biblioteca/ferramenta (a classe WebScraper). Ele orquestra as chamadas para os serviÃ§os e utilitÃ¡rios para realizar as operaÃ§Ãµes de scraping.

Uso: Exporta a classe WebScraper que Ã© a interface principal para os usuÃ¡rios da ferramenta. ContÃ©m a lÃ³gica para scrape uma URL e batchScrape vÃ¡rias URLs.

ğŸ“œ interfaces/ (Pasta):

PropÃ³sito: Define as interfaces TypeScript (contratos) para objetos de dados e configuraÃ§Ãµes. Garante tipagem forte e clareza sobre a estrutura dos dados.

Por que usar: Interfaces sÃ£o cruciais para a confiabilidade do cÃ³digo TypeScript. Elas ajudam a prevenir erros de tipo em tempo de desenvolvimento e melhoram a legibilidade.

Como usar: Outros mÃ³dulos importam essas interfaces para garantir que os dados sigam uma estrutura definida.

ğŸ”§ IConfig.ts: Interface que define a estrutura do objeto de configuraÃ§Ã£o global.

ğŸ‘¤ IProxy.ts: Interface que define a estrutura de um objeto proxy, incluindo host, porta, protocolo e credenciais.

ğŸ“ IScraperOptions.ts: Interface que define as opÃ§Ãµes que podem ser passadas para uma operaÃ§Ã£o de scraping individual.

ğŸ› ï¸ services/ (Pasta):

PropÃ³sito: ContÃ©m a lÃ³gica de negÃ³cio e as classes que realizam operaÃ§Ãµes especÃ­ficas e complexas, como gerenciamento de proxies e requisiÃ§Ãµes HTTP.

Por que usar: A separaÃ§Ã£o de serviÃ§os promove a modularidade e a reutilizaÃ§Ã£o do cÃ³digo. Cada serviÃ§o tem uma responsabilidade clara.

Como usar: As classes dentro desta pasta sÃ£o instanciadas ou seus mÃ©todos estÃ¡ticos sÃ£o chamados pelos componentes de alto nÃ­vel (como index.ts).

ğŸ“¡ Proxy.ts:

PropÃ³sito: Gerencia a obtenÃ§Ã£o, validaÃ§Ã£o e rotaÃ§Ã£o de proxies. Ele pode buscar proxies de uma API externa, cacheÃ¡-los e fornecer um proxy aleatÃ³rio quando solicitado.

Uso: Fornece mÃ©todos estÃ¡ticos como getRandomProxy() e validateProxy() para que outras partes da aplicaÃ§Ã£o possam integrar o uso de proxies facilmente.

ğŸ”— request.ts: (Anteriormente requests.ts, classe RequestService agora Request)

PropÃ³sito: Encapsula a lÃ³gica para fazer requisiÃ§Ãµes HTTP usando axios, incluindo tratamento de retentativas, atrasos e uso de proxies.

Uso: A classe Request Ã© instanciada para cada operaÃ§Ã£o de scraping, configurando o axios com as opÃ§Ãµes fornecidas e lidando com a resposta ou erro.

ğŸ“ types/ (Pasta):

PropÃ³sito: Armazena definiÃ§Ãµes de tipo TypeScript que nÃ£o sÃ£o interfaces, mas sim aliases de tipo ou declaraÃ§Ãµes de mÃ³dulo.

Por que usar: Organiza e centraliza tipos complexos ou especÃ­ficos do projeto, mantendo o cÃ³digo mais limpo.

Como usar: Exporta tipos que sÃ£o usados em outras partes da aplicaÃ§Ã£o para garantir a seguranÃ§a de tipo.

ğŸ·ï¸ index.d.ts:

PropÃ³sito: Reexporta interfaces de outras pastas para simplificar importaÃ§Ãµes e inclui declaraÃ§Ãµes de mÃ³dulo, como para arquivos JSON. Define tambÃ©m tipos de uniÃ£o como OutputFormat e a interface IScraperResult que descreve o resultado de uma operaÃ§Ã£o de scraping.

Uso: Usado globalmente para tipagem.

ğŸ§° utils/ (Pasta):

PropÃ³sito: ContÃ©m funÃ§Ãµes e classes utilitÃ¡rias que fornecem funcionalidades auxiliares e nÃ£o se encaixam diretamente nos serviÃ§os principais.

Por que usar: Evita a duplicaÃ§Ã£o de cÃ³digo e mantÃ©m funÃ§Ãµes genÃ©ricas e reutilizÃ¡veis em um local centralizado.

Como usar: MÃ©todos estÃ¡ticos ou funÃ§Ãµes independentes que sÃ£o importadas e usadas onde necessÃ¡rio.

âœï¸ DataFormatter.ts: (Anteriormente DataFormatters.ts)

PropÃ³sito: Converte e formata dados brutos em diferentes formatos de saÃ­da, como JSON, XML, HTML ou texto puro.

Uso: Fornece um mÃ©todo estÃ¡tico format() que recebe os dados e o formato desejado, retornando a string formatada.

ğŸ”’ SecurityUtils.ts:

PropÃ³sito: Oferece utilitÃ¡rios relacionados Ã  seguranÃ§a, como a geraÃ§Ã£o de cabeÃ§alhos HTTP "seguros" (que simulam navegadores) e sanitizaÃ§Ã£o de entradas.

Uso: Usado para gerar cabeÃ§alhos para requisiÃ§Ãµes e limpar dados para evitar vulnerabilidades.

â³ delay.ts:

PropÃ³sito: Fornece funÃ§Ãµes para introduzir atrasos no fluxo de execuÃ§Ã£o, tanto atrasos fixos quanto aleatÃ³rios.

Uso: Essencial para web scraping para evitar sobrecarregar servidores e reduzir a chance de ser bloqueado ao simular comportamento humano.

ğŸ“¢ logger.ts:

PropÃ³sito: Um utilitÃ¡rio para logs personalizados com diferentes nÃ­veis (INFO, SUCCESS, WARN, ERROR, DEBUG) e formataÃ§Ã£o colorida, alÃ©m de timestamps.

Uso: Usado em toda a aplicaÃ§Ã£o para registrar eventos, depurar problemas e fornecer feedback ao usuÃ¡rio.

ğŸ“„ package.json
PropÃ³sito: O manifesto do projeto Node.js. Ele lista metadados sobre o projeto (nome, versÃ£o, descriÃ§Ã£o, autor, licenÃ§a), scripts de execuÃ§Ã£o (build, test) e todas as dependÃªncias (axios).

Por que usar: Ã‰ essencial para gerenciar as dependÃªncias do projeto e definir scripts para automatizar tarefas.

Como usar: npm install (ou yarn install) para instalar as dependÃªncias. npm run build para compilar o TypeScript.

ğŸ”’ package-lock.json
PropÃ³sito: Registra as versÃµes exatas de todas as dependÃªncias (incluindo sub-dependÃªncias) instaladas no projeto.

Por que usar: Garante que o projeto seja construÃ­do de forma consistente em diferentes ambientes, evitando problemas de compatibilidade causados por versÃµes de dependÃªncias.

Como usar: Gerenciado automaticamente pelo npm; vocÃª geralmente nÃ£o edita este arquivo manualmente.

ğŸ“– README.md
PropÃ³sito: O ponto de partida para qualquer um que visite seu repositÃ³rio. Deve fornecer uma visÃ£o geral do projeto, como instalÃ¡-lo, usÃ¡-lo e as principais funcionalidades.

Por que usar: Ã‰ o primeiro contato de um usuÃ¡rio ou colaborador com seu projeto, essencial para comunicar seu propÃ³sito e como ele funciona.

Como usar: Mantenha-o atualizado com as informaÃ§Ãµes mais importantes.

ğŸ“ tsconfig.json
PropÃ³sito: O arquivo de configuraÃ§Ã£o do compilador TypeScript. Ele define como o TypeScript deve compilar seu cÃ³digo-fonte (por exemplo, qual versÃ£o do JavaScript gerar, onde colocar os arquivos compilados, quais pastas incluir/excluir).

Por que usar: Essencial para projetos TypeScript, pois controla o processo de transpilaÃ§Ã£o e garante que o cÃ³digo seja compilado corretamente.

Como usar: VocÃª o configura uma vez e o compilador TypeScript (tsc) o utiliza automaticamente.

ğŸ—‘ï¸ struct.txt
PropÃ³sito: Este arquivo foi usado para descrever a estrutura do seu projeto inicialmente.

Por que usar: Ãštil durante a fase de planejamento ou para comunicar a estrutura.

Como usar: Uma vez que a estrutura fÃ­sica do projeto esteja consolidada e documentada em outros lugares (como este guia ou um ARCHITECTURE.md), este arquivo pode ser removido.